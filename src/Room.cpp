#include "DXUT.h"
#include "Room.h"


//////////////////////////////////////////////////////////////////////////
// 전역변수 선언
CString		CRoom::m_EntityType = "Room"; // 엔티티별 타입 이름
D3DXVECTOR3 G_RoomPoint_Max = D3DXVECTOR3(232.0f, 43.0f, 152.5f);
D3DXVECTOR3 G_RoomPoint_Min = D3DXVECTOR3(-234.6f, -0.9f, -198.2f);

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
// 
// 여기서부터 stuct ROOM_DATA 함수정의 .. 
// 
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
ROOM_DATA::ROOM_DATA()
{

}



///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
// 
// 여기서부터 class CRoom 함수정의 .. 
// 
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
// 생성자
//-------------------------------------------------------------------------
CRoom::CRoom()
{
  //  m_hTech = G_FXShader.GetPointer()->GetTechniqueByName("PointLight_tex_ppl");
	D3DXMatrixIdentity(&m_MTrans);
	D3DXMatrixIdentity(&m_MRot);
	D3DXMatrixIdentity(&m_MWorld); //[2014.11.12 ]
	D3DXMatrixIdentity(&m_MRotPitch);
	D3DXMatrixIdentity(&m_MRotRoll);
	D3DXMatrixIdentity(&m_MRotYaw);
}

//-------------------------------------------------------------------------
// 소멸자
//-------------------------------------------------------------------------
CRoom::~CRoom()
{

}

//-------------------------------------------------------------------------
// 그리기 함수
// from IRenderable 가상함수 재정의 [2014.11.11 ]
//-------------------------------------------------------------------------
void	CRoom::Draw()
{
	//셰이더상수 설정
	_OnDrawStart();

	m_RscPack.Draw(m_pDevice);
}

//-----------------------------------------------------------------------------
// Arg    : float _dTime (delay time)
// Return : 
// Desc   : from IProgressable 방은 움직이지 않지만 나중을 위해 업데이트속성을 갖게해주자  [2014.11.14 ] 
//-----------------------------------------------------------------------------
void		CRoom::Update(float _dTime)
{
	D3DXMatrixIdentity(&m_MTrans);
	D3DXMatrixTranslation(&m_MTrans, m_Pos.x , m_Pos.y , m_Pos.z);

	m_MWorld = m_MRot * m_MTrans;//최종행렬 계산

	m_RscPack.m_pMeshList->Update(m_RscPack.m_Animator , &m_MWorld);	

}


//-------------------------------------------------------------------------
// Desc  : from ICollidable 을 상속받는 클래스는 
//         반드시 재정의   [2014.11.11 ]
//-------------------------------------------------------------------------
HRESULT		CRoom::InitCollider()//[2014.11.11 ]
{
	HRESULT hr = S_OK;

	m_pCollidObj = new CBoundSphere();

	return hr;

}


//-------------------------------------------------------------------------
//초기화할때 필요한 함수
//  [2014.11.11 ]
//-------------------------------------------------------------------------
int		CRoom::Init(LPDIRECT3DDEVICE9 _pDevice , D3DXVECTOR3 _SPos/* = D3DXVECTOR3(0,0,0)*/,
					ROOM_DATA* pRoomData/*= nullptr*/ )
{
	HRESULT RET = S_OK;
	if(FAILED(CEntity::Init(_pDevice)))		
	{
		return FALSE;
	}

	if(pRoomData != nullptr)
	{
		memcpy(&m_RoomData, pRoomData, sizeof(BEAR_DATA));
	}

	m_VecRight = D3DXVECTOR3(1,0,0);
	m_VecSee   = D3DXVECTOR3(0,1,0); 
	m_VecUp    = D3DXVECTOR3(0,0,1);

	m_Pos = _SPos;

	m_RoomDataBck = m_RoomData;

	return RET;


}


//-------------------------------------------------------------------------
// Arg	  : 
// Return :
// Desc   :  [2014.11.11 ]
//-------------------------------------------------------------------------
void	CRoom::_OnDrawStart()
{
	//
	//셰이더 상수 설정
	{

		// 어떤테크닉을 쓸꺼냐 시작할때 반드시 결정 해서 핸들을 저장해 놓는다.[2014.10.29 ]
		// 		if(SHG_Input.key(DIK_P))
		// 			m_hTech = G_FXShader.GetPointer()->GetTechniqueByName("Skinning_DirLight_SpecularMap");
		// 		else
		// 			m_hTech = G_FXShader.GetPointer()->GetTechniqueByName("Skinning_DirLight");
		// 1. 이펙트 객체 가져오기	[2014.11.12 ]
		LPD3DXEFFECT pEff = G_FXShader.GetPointer();                             

		CCamera* pThisSceneCamera = SHGlobal_GetCurScene_Camera;
		D3DXMATRIX tempViewProjTM; //
		tempViewProjTM = pThisSceneCamera->Get_ViewProjMat();
		// viewPorj TM 을 핸들로 셰이더에 전달 [2014.10.27 ]
		pEff->SetMatrix(G_ConstantTable.h_ViewProjTM , &tempViewProjTM);

		pEff->SetMatrix(G_ConstantTable.h_WorldTM , &m_MWorld);

		//pEff->SetVector(G_ConstantTable.h_PointLightPos , &G_PointLightPosition);
		//pEff->SetFloat(G_ConstantTable.h_PointLightRadius , G_PointLightRadius);
		//pEff->SetVector(G_ConstantTable.h_LightDiff , (D3DXVECTOR4*)&G_LightDiff);

		//D3DXVECTOR4 TempLight = (D3DXVECTOR4)(G_vecDirLight * -1.0f);
		//TempLight.w  = 0.0f;
		//pEff->SetVector(G_ConstantTable.h_LightDir , (D3DXVECTOR4*)&TempLight);

		pEff->SetVector(G_ConstantTable.h_LightAmbi , (D3DXVECTOR4*)&G_LightAmbi);
		pEff->SetFloat(G_ConstantTable.h_UVAni_Val , 0);
		D3DXVECTOR4 ViewPos = pThisSceneCamera->GetPos();
		ViewPos.w = 1.0f;
		pEff->SetVector(G_ConstantTable.h_ViewPos , (D3DXVECTOR4*)(&ViewPos));

		//
		//[2014.12.4] 이병환 ==================================================
		D3DXVECTOR4 FogColor(0.1f, 0.1f, 0.2f, 1.0f );
		pEff->SetVector("gFogColor", &FogColor );

		D3DXVECTOR4 FogValue(0.1f, 200.0f, 1.0f, 500.0f ); //x,y = 방에 해당되는 포그 밀도값이랑 거리 , z,w는 고스트에 해당되는값
		pEff->SetVector("gFogValue", &FogValue );
		//=====================================================================
		if(m_hTech == nullptr )  // 테크 핸들 확인해보기
		{		assert(false);	} // [2014.10.30 ]

		//G_FXShader.GetPointer()->SetTechnique(m_hTech);


	}

}
	


/*************************************  end of "Room.cpp" ****************************************/
